{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n'use strict';\n\nconst EventEmitter = require('events');\n\nconst https = require('https');\n\nconst http = require('http');\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst {\n  randomBytes,\n  createHash\n} = require('crypto');\n\nconst {\n  Readable\n} = require('stream');\n\nconst {\n  URL\n} = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst Receiver = require('./receiver');\n\nconst Sender = require('./sender');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\n\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = require('./event-target');\n\nconst {\n  format,\n  parse\n} = require('./extension');\n\nconst {\n  toBuffer\n} = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\n\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n\n\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type; //\n    // Allow to change `binaryType` on the fly.\n    //\n\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Boolean}\n   */\n\n\n  get isPaused() {\n    return this._paused;\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onclose() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onerror() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onopen() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onmessage() {\n    return null;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n\n\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n\n\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n\n\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    }); //\n    // Specify a timeout for the closing handshake to complete.\n    //\n\n\n    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n  }\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n\n\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n\n    this._paused = true;\n\n    this._socket.pause();\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n\n\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n\n\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n\n      this._socket.destroy();\n    }\n  }\n\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\n\n\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n}); //\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\n\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = { ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalUnixSocket = isUnixSocket;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers; //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n\n      options = { ...options,\n        headers: {}\n      };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || websocket._originalSecure && !isSecure) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = undefined;\n      }\n    } //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n\n\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', err => {\n    if (req === null || req[kAborted]) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res); //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  req.end();\n}\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\n\n\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\n\n\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\n\n\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length; //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    cb(err);\n  }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\n\n\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\n\n\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\n\n\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData); //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n\n\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\n\n\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\n\n\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\n\n\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\n\n\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\n\n\nfunction resume(stream) {\n  stream.resume();\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\n\n\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk; //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\n\n\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n\n  websocket._receiver.end();\n\n  this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}","map":{"version":3,"names":["EventEmitter","require","https","http","net","tls","randomBytes","createHash","Readable","URL","PerMessageDeflate","Receiver","Sender","BINARY_TYPES","EMPTY_BUFFER","GUID","kForOnEventAttribute","kListener","kStatusCode","kWebSocket","NOOP","EventTarget","addEventListener","removeEventListener","format","parse","toBuffer","closeTimeout","kAborted","Symbol","protocolVersions","readyStates","subprotocolRegex","WebSocket","constructor","address","protocols","options","_binaryType","_closeCode","_closeFrameReceived","_closeFrameSent","_closeMessage","_closeTimer","_extensions","_paused","_protocol","_readyState","CONNECTING","_receiver","_sender","_socket","_bufferedAmount","_isServer","_redirects","undefined","Array","isArray","initAsClient","binaryType","type","includes","bufferedAmount","_writableState","length","_bufferedBytes","extensions","Object","keys","join","isPaused","onclose","onerror","onopen","onmessage","protocol","readyState","url","_url","setSocket","socket","head","receiver","isServer","maxPayload","skipUTF8Validation","generateMask","on","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError","OPEN","emit","emitClose","CLOSED","extensionName","cleanup","removeAllListeners","close","code","data","msg","abortHandshake","_req","CLOSING","errorEmitted","end","err","destroy","bind","pause","ping","mask","cb","Error","toString","sendAfterClose","pong","resume","needDrain","send","opts","binary","compress","fin","terminate","defineProperty","enumerable","value","indexOf","prototype","forEach","property","method","get","listener","listeners","set","handler","removeListener","module","exports","websocket","protocolVersion","perMessageDeflate","followRedirects","maxRedirects","createConnection","socketPath","hostname","timeout","host","path","port","RangeError","parsedUrl","href","e","SyntaxError","isSecure","isUnixSocket","invalidURLMessage","pathname","hash","emitErrorAndClose","defaultPort","key","request","protocolSet","Set","tlsConnect","netConnect","startsWith","slice","headers","Connection","Upgrade","search","handshakeTimeout","offer","test","has","add","origin","Origin","username","password","auth","parts","split","req","_originalUnixSocket","_originalSecure","_originalHostOrSocketPath","entries","toLowerCase","listenerCount","isSameHost","authorization","cookie","Buffer","from","res","location","statusCode","abort","addr","upgrade","digest","update","serverProt","protError","size","secWebSocketExtensions","message","extensionNames","accept","connect","servername","isIP","stream","captureStackTrace","setHeader","destroyed","process","nextTick","once","reason","receiverOnFinish","isBinary","chunk","_readableState","endEmitted","read","write","clearTimeout","finished"],"sources":["/home/giparang/threadweb/fortune/client/node_modules/ws/lib/websocket.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalUnixSocket = isUnixSocket;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isUnixSocket\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isUnixSocket\n        ? websocket._originalUnixSocket\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalUnixSocket\n        ? false\n        : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  req.end();\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}