{"ast":null,"code":"'use strict';\n\nconst {\n  kForOnEventAttribute,\n  kListener\n} = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n/**\n * Class representing an event.\n */\n\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get target() {\n    return this[kTarget];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get type() {\n    return this[kType];\n  }\n\n}\n\nObject.defineProperty(Event.prototype, 'target', {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, 'type', {\n  enumerable: true\n});\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\n\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(type);\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get code() {\n    return this[kCode];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get reason() {\n    return this[kReason];\n  }\n  /**\n   * @type {Boolean}\n   */\n\n\n  get wasClean() {\n    return this[kWasClean];\n  }\n\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'reason', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'wasClean', {\n  enumerable: true\n});\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\n\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(type);\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get error() {\n    return this[kError];\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get message() {\n    return this[kMessage];\n  }\n\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, 'message', {\n  enumerable: true\n});\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\n\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(type);\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n  /**\n   * @type {*}\n   */\n\n\n  get data() {\n    return this[kData];\n  }\n\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', {\n  enumerable: true\n});\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\n\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n\n};\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\n\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}","map":{"version":3,"names":["kForOnEventAttribute","kListener","require","kCode","Symbol","kData","kError","kMessage","kReason","kTarget","kType","kWasClean","Event","constructor","type","target","Object","defineProperty","prototype","enumerable","CloseEvent","options","code","undefined","reason","wasClean","ErrorEvent","error","message","MessageEvent","data","EventTarget","addEventListener","handler","listener","listeners","wrapper","onMessage","isBinary","event","toString","callListener","onClose","_closeFrameReceived","_closeFrameSent","onError","onOpen","once","on","removeEventListener","removeListener","module","exports","thisArg","handleEvent","call"],"sources":["/home/giparang/threadweb/fortune/client/node_modules/ws/lib/event-target.js"],"sourcesContent":["'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}